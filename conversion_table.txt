# Define como as instruções do assembly inventado devem ser convertidas
# para o assembly x86 NASM
ADD @rot > ADD eax, [@rot]
SUB @rot > SUB eax, [@rot]

# Confirmar com o prof que esse mult e div são suficientes
MULT @rot {
    IMULT DWORD [@rot]
    JO _OVERFLOW
}
DIV @rot {
    CDQ
    IDIV DWORD [@rot]
}

JMP @rot =
JMPN @rot > JG @rot
JMPP @rot > JL @rot
JMPZ @rot > JZ @rot

LOAD @rot > MOV eax, [@rot]
STORE @rot > MOV DWORD [@rot], eax
COPY @a, @b {
    MOV ebx, [@a]
    MOV DWORD [@b], ebx
}

INPUT @rot {
    PUSH DWORD @rot
    CALL _INPUT
}
OUTPUT @rot {
    PUSH DWORD @rot
    CALL _OUTPUT
}
C_INPUT @rot {
    PUSH DWORD @rot
    CALL _C_INPUT
}
C_OUTPUT @rot {
    PUSH DWORD @rot
    CALL _C_OUTPUT
}
S_INPUT @rot, @size {
    PUSH DWORD @size
    PUSH DWORD @rot
    CALL _S_INPUT
}
S_OUTPUT @rot, @size {
    PUSH DWORD @size
    PUSH DWORD @rot
    CALL _S_OUTPUT
}

STOP {
    MOV eax, 1
    MOV ebx, 0
    INT 80h
}

SPACE @num > (BSS) RESD @num
CONST @val > (DATA) DD @val

# FALTA FAZER AS FUNÇÕES DE ENTRADA PRINTAREM QUANTOS CARACTERES LERAM E RETORNAREM EM EAX!!!!!